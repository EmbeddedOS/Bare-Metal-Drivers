/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

uint8_t current_task = 1;
uint32_t g_tick_count = 0;

static TCB_t user_tasks[MAX_TASKS] = {
		{.psp_value = IDLE_STACK_START, .run_state = USER_TASK_READY_STATE, .block_count = 0, .task_handler = idle},
		{.psp_value = TASK_1_STACK_START, .run_state = USER_TASK_READY_STATE, .block_count = 0, .task_handler = task_1_handler},
		{.psp_value = TASK_2_STACK_START, .run_state = USER_TASK_READY_STATE, .block_count = 0, .task_handler = task_2_handler},
		{.psp_value = TASK_3_STACK_START, .run_state = USER_TASK_READY_STATE, .block_count = 0, .task_handler = task_3_handler},
		{.psp_value = TASK_4_STACK_START, .run_state = USER_TASK_READY_STATE, .block_count = 0, .task_handler = task_4_handler}
};

int main(void)
{
	/* 1. Enable processor faults. */
	enable_system_fault_exceptions();

	/* 2. Initialize stack for scheduler. */
	init_scheduler_stack();

	/* 3. Initialize stack for tasks. */
	init_tasks_stack();

	/* 4. Initialize sys-tick timer to emit exception every 1ms. */
	init_systick_timer(1000);

	/* 5. Change stack pointer to use PSP and run the first task. */
	switch_to_psp();
	task_1_handler();

    /* 6. Loop forever. */
	for(;;);
}

void schedule(void)
{
	/* 1. Pend the PendSV exception for context switching. */
	uint32_t *pICSR = (uint32_t *)0xE000ED04; // Get Interrupt Control and State Register.
	*pICSR |= (1 << 28);
}

void task_delay(uint32_t tick_count)
{
	if (current_task == 0)
	{ // Not handle delay for IDLE task.
		return;
	}

	// We should disable interrupt to avoid race condition happen on global variables,
	// for example, when we call this function, sys-tick timer could be triggered.
	INTERRUPT_DISABLE();

	user_tasks[current_task].block_count = g_tick_count + tick_count;
	user_tasks[current_task].run_state = USER_TASK_BLOCKED_STATE;

	schedule(); // Schedule for another tasks.

	INTERRUPT_ENABLE();
}

void idle(void)
{
	while(1);
}

uint32_t get_psp_value(void)
{
	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t value)
{
	user_tasks[current_task].psp_value = value;
}

void update_next_task(void)
{
	current_task++;
	current_task %= MAX_TASKS;

	if (user_tasks[current_task].run_state != USER_TASK_READY_STATE)
	{ //Move to the next task, if current task is not ready
		update_next_task();
	}
}

void enable_system_fault_exceptions(void)
{
	uint32_t *pSHCSR = (uint32_t *)0xE000ED24; 	// Get System Handler Control and State Register.
	*pSHCSR |= (1 << 16); 						// Memory manage fault.
	*pSHCSR |= (1 << 17); 						// Bus fault.
	*pSHCSR |= (1 << 18); 						// Usage fault.
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t count = SYSTICK_TIM_CLOCK/tick_hz - 1;
	uint32_t *pSYST_RVR = (uint32_t *)0xE000E014;   // Get Sys-tick reload value register.
	uint32_t *pSYST_CSR = (uint32_t *)0xE000E010;   // Get Sys-tick control and status register.

	/* 1. Clear and setup reload register. */
	*pSYST_RVR &= ~(0xFFFFFFFF);
	*pSYST_RVR |= count;

	/* 2. Enable sys-tick timer. */
	*pSYST_CSR |= (1 << 1); // Enable exception request.
	*pSYST_CSR |= (1 << 2); // Using processor clock source.
	*pSYST_CSR |= (1 << 0); // Enable Sys-tick timer.
}

__attribute__((naked)) void init_scheduler_stack(void)
{
	/* 1. Configure MSP point to scheduler stack start. */
	uint32_t scheduler_stack_start = SCHED_STACK_START;
	__asm volatile("MSR MSP, %0":: "r" (scheduler_stack_start):);

	/* 2. Return to caller. */
	__asm volatile("BX LR");
}

/* We need to setup dummy stack frame, so when first time we switch
 * context to the task, we can pop something from stack frames to
 * retrieve the task's context.
 */
void init_tasks_stack(void)
{
	uint32_t *pPSP = NULL;

	for (int i = 0; i < MAX_TASKS; i++)
	{ // Initialize dummy stack frames for all tasks.
		pPSP = (uint32_t *) user_tasks[i].psp_value;

		/* 1. Dummy XPSR. */
		pPSP--;
		*pPSP = 0x01000000;

		/* 2. Dummy PC (return address). */
		pPSP--;
		*pPSP = (uint32_t) user_tasks[i].task_handler;

		/* 3. Dummy LR (EXC_RETURN). */
		pPSP--;
		*pPSP = 0xFFFFFFFD;

		/* 4. Dummy data for R0 - R12. */
		for (int j = 0; j < 13; j++)
		{
			pPSP--;
			*pPSP = 0x00;
		}

		/* 5. Update the PSP array object. */
		user_tasks[i].psp_value = (uint32_t)pPSP;
	}
}

__attribute__((naked)) void switch_to_psp()
{
	/* 1. Get the PSP value of current task and set it to the PSP register. */
	__asm volatile ("PUSH {LR}"); // We need to PUSH LR to cache this value
								  // (This value holds the address to back to main),
								  // because, following, we will branch and link
								  // to get_psp_value function.
	__asm volatile("BL get_psp_value");
	__asm volatile("MSR PSP, R0");
	__asm volatile ("POP {LR}");

	/* 2. Change to PSP as stack pointer via CONTROL bit[1] register. */
	__asm volatile("MOV R0, #0x02");
	__asm volatile("MSR CONTROL, R0");

	/* 3. Return to caller. */
	__asm volatile("BX LR");
}

void task_1_handler(void)
{
	while(1) {
		printf("task_1_handler\n");
		task_delay(1000);
	}
}

void task_2_handler(void)
{
	while(1) {
		printf("task_2_handler\n");
		task_delay(2000);
	}
}

void task_3_handler(void)
{
	while(1) {
		printf("task_3_handler\n");
		task_delay(4000);
	}
}

void task_4_handler(void)
{
	while(1) {
		printf("task_4_handler\n");
		task_delay(8000);
	}
}

__attribute__((naked)) void PendSV_Handler(void)
{
	/* 1. Save the context of the current task. */
	__asm volatile("MRS R0, PSP");			// Get current PSP.
	__asm volatile("STMDB R0!, {R4-R11}");  // Save stack frame 2 start from current PSP.
											// Stack frame 1 is automatically saved by
											// processor when it switch to handle mode to handle
										 	// Sys-tick exception.
											// STMDB - Store Multiple Decrement Before (Store
											// Multiple Full Descending) stores multiple registers to
											// sequential memory locations using an address
											// from a base register. `!` causing the instruction
											// to write a modified value back to R0.
											// So when we save done, the R0 will hold the current
											// PSP value.

	__asm volatile ("PUSH {LR}");			// Save LR before we Branch everywhere.
	__asm volatile("BL save_psp_value");	// Save current PSP after push stack frame 2,
											// with first argument is R0.
	/* 2. Retrieve the context of the next task. */
	__asm volatile("BL update_next_task");	// Increase the current task to next task.
	__asm volatile("BL get_psp_value");		// Get PSP value of next task and store to R0.
	__asm volatile("LDMIA R0!, {R4-R11}");  // Retrieve stack frame 2 start from PSP's next task.
											// Stack frame 1 of the next task will be retrieved
											// when exception exit automatically by processor.
	__asm volatile("MSR PSP, R0");			// Update PSP value to stack frame 1 after retrieving
											// Stack frame 2.
	__asm volatile ("POP {LR}");

	/* 3. Return to thread mode. */
	__asm volatile("BX LR");
}

void SysTick_Handler(void)
{
	/* 1. Increase global tick count. */
	g_tick_count++;

	/* 2. Unblock blocked tasks if its wake up time. */
	for (int i = 1; i < MAX_TASKS; i++)
	{
		if (user_tasks[i].run_state == USER_TASK_BLOCKED_STATE && user_tasks[i].block_count == g_tick_count)
		{
			user_tasks[i].run_state = USER_TASK_READY_STATE;
		}
	}

	/* 3. Pend the PendSV exception for context switching. */
	uint32_t *pICSR = (uint32_t *)0xE000ED04; // Get Interrupt Control and State Register.
	*pICSR |= (1 << 28);
}

void HardFault_Handler(void)
{
	while(1);
}

void BusFault_Handler(void)
{
	while(1);
}

void UsageFault_Handler(void)
{
	while(1);
}
